module ArcCreator exposing (..)

{-
Copyright 2017-2019 Christopher Kumar Anand,  Adele Olejarz, Chinmay Sheth, Yaminah Qureshi, Graeme Crawley and students of McMaster University.  Based on the Shape Creator by Levin Noronha.

   Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

   1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

   2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution, and cite the paper

   @article{d_Alves_2018,
   title={Using Elm to Introduce Algebraic Thinking to K-8 Students},
   volume={270},
   ISSN={2075-2180},
   url={http://dx.doi.org/10.4204/EPTCS.270.2},
   DOI={10.4204/eptcs.270.2},
   journal={Electronic Proceedings in Theoretical Computer Science},
   publisher={Open Publishing Association},
   author={d’ Alves, Curtis and Bouman, Tanya and Schankula, Christopher and Hogg, Jenell and Noronha, Levin and Horsman, Emily and Siddiqui, Rumsha and Anand, Christopher Kumar},
   year={2018},
   month={May},
   pages={18–36}
   }

   3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR AN, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

-}

import GraphicSVG exposing (..)
import GraphicSVG.EllieApp exposing (..)
import List exposing (..)
import ShapeCreateAssets exposing (..)
import String exposing (..)


init =
    { time = 0
    , notify = NotifyTap
    , shape = BezierPath
    , draw = Filled
    , style = Solid
    , lineWidth = 1
    , width = 10
    , height = 15
    , sides = 5
    , roundness = 5
    , angle = 30
    , mouth = 0.75
    , clr = RGB
    , red = 250
    , green = 150
    , blue = 0
    , alpha = 0.5
    , hasMove = False
    , hasRotate = False
    , hasScale = False
    , hasScaleX = False
    , hasScaleY = False
    , hasMakeTransparent = False
    , hasCurveHelper = True
    , bezierTrue = True
    , pulls = [ ( ( 0, 0 ), ( 0, 0 ) ) ]
    , curvex1 = 0
    , curvey1 = 0
    , magicrect = 0
    , flashon = 1
    , scl = 2
    , sclx = 2
    , scly = 2
    , x = 5
    , y = 0
    , pullShift = 0
    , moreplus = 0
    , lessminus = 0
    , location = ( -201, 176 )
    , currentButton = None
    , buttonDownTime = 0
    }



-- TYPES
-- messages generated by the framework (Tick) and by user interactions
-- note that we let elm figure out the type of the model by making it a type parameter, m


type Msg m
    = Tick Float GetKeyState
    | Sten Stencil
    | Draw Draw
    | LStyle
    | SetColour Colour
    | Toggle Transforms
    | TransM (m -> m)
    | Notif Notifications
    | PullShift (m -> m)
    | Validate ValidateArrow
    | MovePoint Direction
    | ButtonDown ButtonDir


type Direction
    = Up
    | Down
    | Left
    | Right



-- the type of stencil selected, these correspond to functions exported by GraphicSVG
--for arc, the only option should be.. arc!


type Stencil
    = BezierPath


type Draw
    = Filled
    | Outlined


type Colour
    = RGB


type Transforms
    = Rotate
    | Scale
    | ScaleX
    | ScaleY
    | MakeTransparent
    | CurveHelper


type Notifications
    = NotifyTap
    | NotifyTapAt
    | NotifyEnter
    | NotifyEnterAt
    | NotifyLeave
    | NotifyLeaveAt
    | NotifyMouseMoveAt
    | NotifyMouseDown
    | NotifyMouseDownAt
    | NotifyMouseUp
    | NotifyMouseUpAt
    | NotifyTouchStart
    | NotifyTouchStartAt
    | NotifyTouchEnd
    | NotifyTouchEndAt
    | NotifyTouchMoveAt


type LineStyle
    = Solid
    | Dotted
    | Dashed
    | Longdash
    | Dotdash


type ValidateArrow
    = UpArrow
    | DownArrow
    | LeftArrow
    | RightArrow


type ButtonDir
    = CurveUp
    | CurveDown
    | CurveLeft
    | CurveRight
    | None
    | RUp
    | RDown
    | GUp
    | GDown
    | BUp
    | BDown



-- UPDATE


update msg model =
    case msg of
        Tick t _ ->
            { model
                | time = t
                , buttonDownTime =
                    case model.currentButton of
                        None ->
                            0

                        _ ->
                            model.buttonDownTime + 0.1
                , curvex1 =
                    case model.magicrect of
                        0 ->
                            case model.currentButton of
                                CurveRight ->
                                    model.curvex1 + curveMovingFunction model.buttonDownTime

                                CurveLeft ->
                                    model.curvex1 - curveMovingFunction model.buttonDownTime

                                _ ->
                                    model.curvex1

                        _ ->
                            model.curvex1
                , curvey1 =
                    case model.magicrect of
                        0 ->
                            case model.currentButton of
                                CurveUp ->
                                    model.curvey1 + curveMovingFunction model.buttonDownTime

                                CurveDown ->
                                    model.curvey1 - curveMovingFunction model.buttonDownTime

                                _ ->
                                    model.curvey1

                        _ ->
                            model.curvey1
                , pulls =
                    let
                        replacePull target current pulls =
                            case pulls of
                                ( ( x1, y1 ), ( x2, y2 ) ) :: rest ->
                                    if target == current then
                                        -- replace p1
                                        ( ( case model.currentButton of
                                                CurveRight ->
                                                    x1 + curveMovingFunction model.buttonDownTime

                                                CurveLeft ->
                                                    x1 - curveMovingFunction model.buttonDownTime

                                                _ ->
                                                    x1
                                          , case model.currentButton of
                                                CurveUp ->
                                                    y1 + curveMovingFunction model.buttonDownTime

                                                CurveDown ->
                                                    y1 - curveMovingFunction model.buttonDownTime

                                                _ ->
                                                    y1
                                          )
                                        , ( x2, y2 )
                                        )
                                            :: rest

                                    else if target == current + 1 then
                                        -- replace p2
                                        ( ( x1, y1 )
                                        , ( case model.currentButton of
                                                CurveRight ->
                                                    x2 + curveMovingFunction model.buttonDownTime

                                                CurveLeft ->
                                                    x2 - curveMovingFunction model.buttonDownTime

                                                _ ->
                                                    x2
                                          , case model.currentButton of
                                                CurveUp ->
                                                    y2 + curveMovingFunction model.buttonDownTime

                                                CurveDown ->
                                                    y2 - curveMovingFunction model.buttonDownTime

                                                _ ->
                                                    y2
                                          )
                                        )
                                            :: rest

                                    else
                                        ( ( x1, y1 ), ( x2, y2 ) ) :: replacePull target (current + 2) rest

                                [] ->
                                    []
                    in
                    replacePull model.magicrect 1 model.pulls
                , red =
                    case model.magicrect of
                        _ ->
                            case model.currentButton of
                                RUp ->
                                    clamp 0 255 (model.red + curveMovingFunction model.buttonDownTime)

                                RDown ->
                                    clamp 0 255 (model.red - curveMovingFunction model.buttonDownTime)

                                _ ->
                                    model.red
                , green =
                    case model.magicrect of
                        _ ->
                            case model.currentButton of
                                GUp ->
                                    clamp 0 255 (model.green + curveMovingFunction model.buttonDownTime)

                                GDown ->
                                    clamp 0 255 (model.green - curveMovingFunction model.buttonDownTime)

                                _ ->
                                    model.green
                , blue =
                    case model.magicrect of
                        _ ->
                            case model.currentButton of
                                BUp ->
                                    clamp 0 255 (model.blue + curveMovingFunction model.buttonDownTime)

                                BDown ->
                                    clamp 0 255 (model.blue - curveMovingFunction model.buttonDownTime)

                                _ ->
                                    model.blue
            }

        ButtonDown dir ->
            { model | currentButton = dir }

        Sten BezierPath ->
            { model | shape = BezierPath }

        Draw draw ->
            { model | draw = draw }

        LStyle ->
            { model
                | style =
                    case model.style of
                        Solid ->
                            Dotted

                        Dotted ->
                            Dashed

                        Dashed ->
                            Longdash

                        Longdash ->
                            Dotdash

                        _ ->
                            Solid
            }

        Toggle Rotate ->
            { model | hasRotate = not model.hasRotate }

        Toggle Scale ->
            { model | hasScale = not model.hasScale }

        Toggle ScaleX ->
            { model | hasScaleX = not model.hasScaleX }

        Toggle ScaleY ->
            { model | hasScaleY = not model.hasScaleY }

        Toggle MakeTransparent ->
            { model | hasMakeTransparent = not model.hasMakeTransparent }

        Toggle CurveHelper ->
            { model | hasCurveHelper = not model.hasCurveHelper }

        Validate UpArrow ->
            { model | y = 0 }

        Validate DownArrow ->
            { model | y = 0 }

        Validate LeftArrow ->
            { model | y = 0 }

        Validate RightArrow ->
            { model | y = 0 }

        TransM t ->
            t model

        SetColour clr ->
            { model | clr = clr }

        PullShift t ->
            t model

        -- ran out of room for notifications, but left them here for a possible future improvement
        Notif notif ->
            { model | notify = notif }

        ---NEW
        --CONTROLS SINGLE CLICK MOVEMENT OF THE POINTS
        MovePoint direct ->
            let
                replacePull target current pulls =
                    case pulls of
                        ( ( x1, y1 ), ( x2, y2 ) ) :: rest ->
                            if target == current then
                                ( movePoint ( x1, y1 ) direct, ( x2, y2 ) ) :: rest

                            else if target == current + 1 then
                                ( ( x1, y1 ), movePoint ( x2, y2 ) direct ) :: rest

                            else
                                ( ( x1, y1 ), ( x2, y2 ) ) :: replacePull target (current + 2) rest

                        [] ->
                            []

                ( cx1, cy1 ) =
                    movePoint ( model.curvex1, model.curvey1 ) direct
            in
            if model.magicrect /= 0 then
                { model
                    | pulls = replacePull model.magicrect 1 model.pulls
                }

            else
                { model
                    | curvex1 = cx1
                    , curvey1 = cy1
                }



-- VIEW


view model =
    [ group
        [ graphPaperCustom 10 1 (rgb 117 184 135) |> makeTransparent 0.25 -- axes and selected coordinate ticks
        , rect 512 0.5 |> filled (rgb 117 184 135)
        , rect 0.5 512 |> filled (rgb 117 184 135)
        , rect 4 0.5 |> filled orange |> move ( 0, 100 )
        , text "(0,100)" |> size 7 |> filled orange |> move ( 3, 100 )
        , rect 4 0.5 |> filled orange |> move ( 0, -100 )
        , text "(0,-100)" |> size 7 |> filled orange |> move ( 3, -100 )
        , rect 0.5 4 |> filled orange |> move ( -100, 0 )
        , text "(-100,0)" |> size 7 |> filled orange |> move ( -100, 3 )
        , rect 0.5 4 |> filled orange |> move ( 100, 0 )
        , text "(100,0)" |> size 7 |> filled orange |> move ( 100, 3 )
        , rect 0.5 4 |> filled orange |> move ( -200, 0 )
        , text "(-200,0)" |> size 7 |> filled orange |> move ( -200, 3 )
        , rect 0.5 4 |> filled orange |> move ( 200, 0 )
        , text "(200,0)" |> size 7 |> filled orange |> move ( 200, 3 ) -- put the drawn shape above the graph paper, but under the transparent controls
        , shapeFun model
        ]
        |> move ( 0, -30 )
    , stencils model |> move ( -150, 170 )
    , brackets model
    , code "|>" |> move ( 115, -20 )
    , stamps model |> move ( 230, -20 )
    , group (magicRect model)
    , code " " |> move ( 110, 165 )
    , colours model |> move ( 230, 169 )
    , transforms model |> move ( -150, 30 )
    , tweaks |> move ( 230, -60 )
    , yourCode model |> move ( 35, -150 ) |> scale 1.2
    , group [ keypad (rgba 117 184 135 0.2) model ] --- NEW
    , group <|
        if List.length model.pulls > 1 then
            List.map
                (\idx ->
                    group [ circle 10 |> filled red, rect 5 15 |> filled white |> rotate (degrees 45), rect 5 15 |> filled white |> rotate (degrees -45) ]
                        |> scale 0.5
                        |> move ( 10, 170 - 20 * Basics.toFloat idx )
                        |> notifyTap
                            (TransM
                                (\m ->
                                    let
                                        ps =
                                            m.pulls

                                        len =
                                            List.length ps
                                    in
                                    { m
                                        | pulls =
                                            if len > 1 then
                                                List.take (idx - 1) ps ++ List.drop idx ps

                                            else
                                                ps
                                        , location = ( -181, 156 )
                                        , magicrect = 1
                                    }
                                )
                            )
                 -- FIXME  only change this if we are deleting this square
                )
                (List.range 1 (List.length model.pulls))

        else
            []
    , group <|
        List.map
            (\idx ->
                group [ circle 10 |> filled green, rect 5 15 |> filled white |> rotate (degrees 90), rect 5 15 |> filled white ]
                    |> scale 0.5
                    |> move ( -240, 160 - 20 * Basics.toFloat idx )
                    |> notifyTap
                        (TransM
                            (\m ->
                                let
                                    ps =
                                        m.pulls

                                    len =
                                        List.length ps
                                in
                                { m
                                    | pulls =
                                        if len < 7 then
                                            List.take idx ps ++ [ ( ( 0, 0 ), ( 0, 0 ) ) ] ++ List.drop idx ps

                                        else
                                            ps
                                }
                            )
                        )
            )
            -- FUNCTIONALITY TO LIMIT THE AVAILABILITY OF THE PLUS BUTTONS
            (if List.length model.pulls < 7 then
                List.range 0 (List.length model.pulls)

             else
                []
            )
    ]



-- HELPER FUNCTIONS


curveMovingFunction x =
    Basics.toFloat (round (clamp 0 12 (x ^ 2) / 4))


keypad colour model =
    group
        [ polygon [ ( 0, 0 ), ( 80, 0 ), ( 40, 10 ), ( 0, 0 ) ] |> filled colour |> addOutline (solid 1) colour |> notifyTap (MovePoint Up) |> notifyMouseDown (ButtonDown CurveUp) |> notifyMouseUp (ButtonDown None)
        , polygon [ ( 0, 0 ), ( 0, -12 ), ( -10, -6 ), ( 0, 0 ) ] |> filled colour |> addOutline (solid 1) colour |> notifyTap (MovePoint Left) |> notifyMouseDown (ButtonDown CurveLeft) |> notifyMouseUp (ButtonDown None)
        , polygon [ ( 0, -12 ), ( 80, -12 ), ( 40, -22 ), ( 0, -12 ) ] |> filled colour |> addOutline (solid 1) colour |> notifyTap (MovePoint Down) |> notifyMouseDown (ButtonDown CurveDown) |> notifyMouseUp (ButtonDown None)
        , polygon [ ( 80, -12 ), ( 80, 0 ), ( 90, -6 ) ] |> filled colour |> addOutline (solid 1) colour |> notifyTap (MovePoint Right) |> notifyMouseDown (ButtonDown CurveRight) |> notifyMouseUp (ButtonDown None)
        ]
        |> move model.location


movePoint ( x, y ) d =
    case d of
        Left ->
            ( x - 1, y )

        Right ->
            ( x + 1, y )

        Up ->
            ( x, y + 1 )

        Down ->
            ( x, y - 1 )


listOfPoints model =
    List.map2 (\pts idx -> ( pts, idx ))
        -- put all the points in a list
        (concatMap (\( p1, p2 ) -> [ p1, p2 ]) model.pulls)
        [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ]
        ++ [ ( ( model.curvex1, model.curvey1 ), 0 ) ]


invisibleRectangle x y b =
    group [ rect 80 12 |> filled b |> move ( x, y ) ]


flashingCircles model =
    List.map
        (\( ( a, b ), c ) ->
            if model.magicrect == c then
                circle (abs (sin (model.time * 2) / 2 + 2))
                    |> (if modBy 2 c == 1 then
                            outlined (solid 1)

                        else
                            filled
                       )
                        (rgb 117 184 135)
                    |> move ( a, b )

            else
                group []
        )
        (listOfPoints model)


brackets model =
    let
        -- recursively layout pulls, with a starting "start", and ending with a "]"
        layoutPulls ( start, end ) pulls offsets =
            case ( pulls, offsets ) of
                ( ( ( x1, y1 ), ( x2, y2 ) ) :: rest, ( x, y ) :: moreOffsets ) ->
                    [ text (start ++ "Pull ( ") |> fixedwidth |> size 13 |> filled black |> move ( x, y )
                    , text (String.fromFloat x1) |> fixedwidth |> size 13 |> filled black |> move ( x + 52, y )
                    , text "," |> fixedwidth |> size 13 |> filled black |> move ( x + 84, y )
                    , text (String.fromFloat y1) |> fixedwidth |> size 13 |> filled black |> move ( x + 95, y )
                    , text " )" |> fixedwidth |> size 13 |> filled black |> move ( x + 115, y )
                    , text " (" |> fixedwidth |> size 13 |> filled black |> move ( x + 130, y )
                    , text (String.fromFloat x2) |> fixedwidth |> size 13 |> filled black |> move ( x + 145, y )
                    , text "," |> fixedwidth |> size 13 |> filled black |> move ( x + 177, y )
                    , text (String.fromFloat y2) |> fixedwidth |> size 13 |> filled black |> move ( x + 188, y )
                    , text (" )" ++ end) |> fixedwidth |> size 13 |> filled black |> move ( x + 208, y )
                    ]
                        ++ layoutPulls
                            (if List.length rest == 1 then
                                ( ",", "]" )

                             else
                                ( ",", "" )
                            )
                            rest
                            moreOffsets

                ( _, _ ) ->
                    []
    in
    group
        [ -- curve (x,y)
          text "curve ( " |> fixedwidth |> size 13 |> filled black |> move ( -250, 167 )
        , text (String.fromFloat model.curvex1) |> fixedwidth |> size 13 |> filled black |> move ( -198, 167 )
        , text "," |> fixedwidth |> size 13 |> filled black |> move ( -166, 167 )
        , text (String.fromFloat model.curvey1) |> fixedwidth |> size 13 |> filled black |> move ( -155, 167 )
        , text " )" |> fixedwidth |> size 13 |> filled black |> move ( -135, 167 )

        -- pulls
        , group <|
            layoutPulls
                (if List.length model.pulls == 1 then
                    ( "[", "]" )

                 else
                    ( "[", "" )
                )
                model.pulls
                [ ( -230, 147 ), ( -230, 127 ), ( -230, 107 ), ( -230, 87 ), ( -230, 67 ), ( -230, 47 ), ( -230, 27 ), ( -230, 7 ) ]
        ]



-- update helper
-- this case catches every other string and turns it into Hello
-- since there are an infinite number of Strings, we need a catch-all case
-- main view components


stencils model =
    group
        [ rect 255 185 |> filled (rgba 255 255 255 0.5) |> addOutline (solid 1) lightGrey |> move ( 22, -77 )
        , rect 75 12 |> filled white |> addOutline (solid 1) lightGrey |> move ( 0, 13 )
        , text "1.Curve Points" |> serif |> italic |> size 10 |> filled titleColour |> move ( -35, 10 )
        ]


stamps model =
    group
        [ rect 130 30 |> filled (rgba 255 255 255 0.5) |> addOutline (solid 1) lightGrey |> move ( -40, -1 )
        , rect 95 12 |> filled white |> addOutline (solid 1) lightGrey |> move ( -40, 14 )
        , text "4. Fill it or Outline it!" |> serif |> italic |> size 10 |> filled titleColour |> move ( -85, 11 )
        , group <|
            List.map2
                (\ss y ->
                    stampString model ss
                        |> text
                        |> fixedwidth
                        |> size 10
                        |> filled black
                        |> notifyTap (Draw ss)
                        |> move ( -63, -2.5 )
                        |> fillItOrOutlineItTime model ss 130 10
                        |> move ( -40, y )
                )
                [ Filled, Outlined ]
                (List.map (\x -> -10 * Basics.toFloat x) (List.range 0 20))
        , styleString model |> text |> fixedwidth |> size 10 |> filled black |> move ( -43, -12.5 ) |> notifyTap LStyle
        ]



-- Model to show rectangle on top of selected point, and allow for point to be selected


magicRect model =
    let
        len =
            List.length model.pulls

        invisRectLocation =
            [ ( ( -201, 176 ), ( -161, 170 ), ( 0, len > 0 ) )
            , ( ( -181, 156 ), ( -141, 150 ), ( 1, len > 0 ) )
            , ( ( -91, 156 ), ( -51, 150 ), ( 2, len > 0 ) )
            , ( ( -181, 136 ), ( -141, 130 ), ( 3, len > 1 ) )
            , ( ( -91, 136 ), ( -51, 130 ), ( 4, len > 1 ) )
            , ( ( -181, 116 ), ( -141, 110 ), ( 5, len > 2 ) )
            , ( ( -91, 116 ), ( -51, 110 ), ( 6, len > 2 ) )
            , ( ( -181, 96 ), ( -141, 90 ), ( 7, len > 3 ) )
            , ( ( -91, 96 ), ( -51, 90 ), ( 8, len > 3 ) )
            , ( ( -181, 76 ), ( -141, 70 ), ( 9, len > 4 ) )
            , ( ( -91, 76 ), ( -51, 70 ), ( 10, len > 4 ) )
            , ( ( -181, 56 ), ( -141, 50 ), ( 11, len > 5 ) )
            , ( ( -91, 56 ), ( -51, 50 ), ( 12, len > 5 ) )
            , ( ( -181, 36 ), ( -141, 30 ), ( 13, len > 6 ) )
            , ( ( -91, 36 ), ( -51, 30 ), ( 14, len > 6 ) )
            ]
    in
    List.map
        (\( ( a, b ), ( c, d ), ( e, f ) ) ->
            invisibleRectangle c d (rgb 117 255 135)
                |> makeTransparent
                    (if model.magicrect == e && f then
                        abs (sin model.time) * 0.5

                     else
                        0
                    )
                |> notifyTap
                    (TransM
                        (\m ->
                            { m
                                | location =
                                    if f then
                                        ( a, b )

                                    else
                                        m.location
                                , magicrect =
                                    if f then
                                        e

                                    else
                                        m.magicrect
                            }
                        )
                    )
        )
        invisRectLocation


colours model =
    group
        [ rect 140 50 |> filled (rgba 255 255 255 0.5) |> addOutline (solid 1) lightGrey |> move ( -35, -15 )
        , rect 75 12 |> filled white |> addOutline (solid 1) lightGrey |> move ( -40, 14 )
        , text "2.Colour!" |> serif |> italic |> size 10 |> filled titleColour |> move ( -75, 11 )
        , group
            [ triangle 8
                |> filled (rgb 255 10 10)
                |> rotate (degrees -30)
                |> move ( -95, -10 )
                |> notifyMouseDown (ButtonDown RUp)
                |> notifyMouseUp (ButtonDown None)
                |> notifyTap
                    (TransM
                        (\m ->
                            { m
                                | red =
                                    if m.red < 248 then
                                        m.red + 1

                                    else
                                        m.red
                            }
                        )
                    )
            , triangle 8
                |> filled (rgb 180 140 140)
                |> rotate (degrees 30)
                |> move ( -84, -9 )
                |> notifyMouseDown (ButtonDown RDown)
                |> notifyMouseUp (ButtonDown None)
                |> notifyTap
                    (TransM
                        (\m ->
                            { m
                                | red =
                                    if m.red > 7 then
                                        m.red - 1

                                    else
                                        m.red
                            }
                        )
                    )
            , triangle 8
                |> filled (rgb 10 255 10)
                |> rotate (degrees -30)
                |> move ( -65, -10 )
                |> notifyMouseDown (ButtonDown GUp)
                |> notifyMouseUp (ButtonDown None)
                |> notifyTap
                    (TransM
                        (\m ->
                            { m
                                | green =
                                    if m.green < 248 then
                                        m.green + 1

                                    else
                                        m.green
                            }
                        )
                    )
            , triangle 8
                |> filled (rgb 140 180 140)
                |> rotate (degrees 30)
                |> move ( -54, -9 )
                |> notifyMouseDown (ButtonDown GDown)
                |> notifyMouseUp (ButtonDown None)
                |> notifyTap
                    (TransM
                        (\m ->
                            { m
                                | green =
                                    if m.green > 7 then
                                        m.green - 1

                                    else
                                        m.green
                            }
                        )
                    )
            , triangle 8
                |> filled (rgb 10 10 255)
                |> rotate (degrees -30)
                |> move ( -35, -10 )
                |> notifyMouseDown (ButtonDown BUp)
                |> notifyMouseUp (ButtonDown None)
                |> notifyTap
                    (TransM
                        (\m ->
                            { m
                                | blue =
                                    if m.blue < 248 then
                                        m.blue + 1

                                    else
                                        m.blue
                            }
                        )
                    )
            , triangle 8
                |> filled (rgb 140 140 180)
                |> rotate (degrees 30)
                |> move ( -24, -9 )
                |> notifyMouseDown (ButtonDown BDown)
                |> notifyMouseUp (ButtonDown None)
                |> notifyTap
                    (TransM
                        (\m ->
                            { m
                                | blue =
                                    if m.blue > 7 then
                                        m.blue - 1

                                    else
                                        m.blue
                            }
                        )
                    )
            ]
            |> move ( 2, -8 )

        -- ============================================ KEYPAD ===============================================================
        , group <|
            List.map2
                (\ss y ->
                    clrString model ss
                        |> text
                        |> fixedwidth
                        |> size 10
                        |> filled black
                        |> notifyTap (SetColour ss)
                        |> move ( -63, -2.5 )
                        |> colourTime model ss 130 10
                        |> move ( -40, y )
                )
                [ RGB
                ]
                (List.map (\x -> -10 * Basics.toFloat x) (List.range 0 40))
        ]



-- Apply Transforms


transforms model =
    group
        [ rect 140 70 |> filled (rgba 255 255 255 0.5) |> addOutline (solid 1) lightGrey |> move ( 340, 30 )
        , rect 95 12 |> filled white |> addOutline (solid 1) lightGrey |> move ( 340, 68 )
        , text "3. Apply Transforms!" |> serif |> italic |> size 10 |> filled titleColour |> move ( 300, 65 )
        , group <|
            List.map2
                (\ss y ->
                    transformString model ss
                        |> text
                        |> fixedwidth
                        |> size 10
                        |> filled black
                        |> notifyTap (Toggle ss)
                        |> move ( 307, 50 )
                        |> applyTransformsTime model ss 140 10
                        |> move ( -35, y )
                )
                [ Scale, ScaleX, ScaleY, Rotate, MakeTransparent, CurveHelper ]
                (List.map (\x -> -10 * Basics.toFloat x) (List.range 0 20))
        ]



-- Tweak It!


tweaks =
    group
        [ rect 140 50 |> filled (rgba 255 255 255 0.5) |> addOutline (solid 1) lightGrey |> move ( -35, -11 )
        , rect 55 12 |> filled white |> addOutline (solid 1) lightGrey |> move ( -60, 14 )
        , text "5. Tweak it!" |> serif |> italic |> size 10 |> filled titleColour |> move ( -85, 11 )
        , group <|
            List.map2
                (\( str, msg ) ( x, y ) ->
                    str
                        |> text
                        |> fixedwidth
                        |> size 10
                        |> filled black
                        |> notifyTap msg
                        |> move ( -68 + x, -2.5 + y )
                )
                [ ( "clockwise", TransM (\m -> { m | angle = m.angle - 30 }) )
                , ( "counter", TransM (\m -> { m | angle = m.angle + 30 }) )
                , ( "thicker"
                  , TransM
                        (\m ->
                            { m
                                | lineWidth =
                                    if m.lineWidth < 10 then
                                        m.lineWidth + 0.5

                                    else
                                        10
                            }
                        )
                  )
                , ( "thinner"
                  , TransM
                        (\m ->
                            { m
                                | lineWidth =
                                    if m.lineWidth > 0.5 then
                                        m.lineWidth - 0.5

                                    else
                                        0.5
                            }
                        )
                  )
                , ( "solider"
                  , TransM
                        (\m ->
                            { m
                                | alpha =
                                    if m.alpha < 1 then
                                        m.alpha + 0.125

                                    else
                                        1
                            }
                        )
                  )
                , ( "ghostier"
                  , TransM
                        (\m ->
                            { m
                                | alpha =
                                    if m.alpha > 0 then
                                        m.alpha - 0.125

                                    else
                                        0
                            }
                        )
                  )
                , ( "bigger"
                  , TransM
                        (\m ->
                            { m
                                | scl =
                                    if m.scl < 3 then
                                        m.scl + 0.25

                                    else
                                        3
                                , sclx =
                                    if m.sclx < 3 then
                                        m.sclx + 0.25

                                    else
                                        3
                                , scly =
                                    if m.scly < 3 then
                                        m.scly + 0.25

                                    else
                                        3
                            }
                        )
                  )
                , ( "smaller"
                  , TransM
                        (\m ->
                            { m
                                | scl =
                                    if m.scl > -3 then
                                        m.scl - 0.25

                                    else
                                        -3
                                , sclx =
                                    if m.sclx > -3 then
                                        m.sclx - 0.25

                                    else
                                        -3
                                , scly =
                                    if m.scly > -3 then
                                        m.scly - 0.25

                                    else
                                        -3
                            }
                        )
                  )
                ]
                (List.concat <| List.map (\idx -> [ ( -30, -10 * Basics.toFloat idx ), ( 40, -10 * Basics.toFloat idx ) ]) (List.range 0 20))
        ]



-- Copiable Code


yourCode m =
    group
        [ rect 490 85 |> filled (rgba 255 255 255 0.5) |> addOutline (solid 1) lightGrey |> move ( 0, -30 )
        , rect 110 12 |> filled white |> addOutline (solid 1) lightGrey |> move ( -145, 14 )
        , text "6. Your (copiable) code! Use cmd/ctrl-A, cmd/ctrl-C. " |> serif |> italic |> size 10 |> filled titleColour |> move ( -190, 11 )
        , pullsText m |> scale 0.5 |> move ( -240, 0 )
        , move ( -220, 0 ) <|
            group <|
                [ "  |> "
                    ++ stampString m m.draw
                    ++ (if m.draw == Outlined then
                            styleString m ++ " "

                        else
                            ""
                       )
                    ++ clrString m m.clr
                    |> copiable
                    |> scale 0.5
                    |> move ( 0, -10 )
                ]
                    ++ List.map2 (\str y -> str |> code |> scale 0.66 |> move ( 0, y ))
                        (List.concat <|
                            List.map
                                (\( flag, t ) ->
                                    if flag then
                                        [ "  " ++ transformString m t ]

                                    else
                                        []
                                )
                                [ ( m.hasScale, Scale )
                                , ( m.hasScaleX, ScaleX )
                                , ( m.hasScaleY, ScaleY )
                                , ( m.hasRotate, Rotate )
                                , ( m.hasMakeTransparent, MakeTransparent )
                                ]
                        )
                        [ -20, -30, -40, -50, -60, -70, -80 ]
        ] |> move (0,20)



-- check if the drawn text is the selected function, and if so group a beating rectangle behind it
-- stagger the heartbeats of selected elements to so that they indicate the order of selection


pullsText model =
    let
        pulls =
            List.map pullCode <| model.pulls
    in
    group
        [ copiable
            ("curve "
                ++ ptCode ( model.curvex1, model.curvey1 )
                ++ " ["
                ++ (String.concat <| List.intersperse ", " pulls)
                ++ " ]"
            )
        ]



--FLASHING TIMES
-- Functions that define the frequency and phase shift of the flashing buttons
-- Fill it or Outline it! flashing time


fillItOrOutlineItTime model ss w h shape =
    if ss == model.draw then
        group [ rect w h |> filled (rgba 117 184 135 (0.6 + 0.4 * sin (5 * model.time - 0.5))), shape ]

    else
        shape



-- Colour! flashing time


colourTime model ss w h shape =
    if ss == model.clr then
        group [ rect w h |> filled (rgba 117 184 135 (0.6 + 0.4 * sin (5 * model.time - 1))), shape ]

    else
        shape



-- Apply Transforms! flashing time


applyTransformsTime model t w h shape =
    if
        case t of
            Rotate ->
                model.hasRotate

            Scale ->
                model.hasScale

            ScaleX ->
                model.hasScaleX

            ScaleY ->
                model.hasScaleY

            MakeTransparent ->
                model.hasMakeTransparent

            CurveHelper ->
                model.hasCurveHelper
    then
        group [ rect w h |> filled (rgba 117 184 135 (0.6 + 0.4 * sin (5 * model.time - 1.5))) |> move ( 375, 53 ), shape ]

    else
        shape



-- view helpers


stencilFun m =
    case m.shape of
        BezierPath ->
            curve ( m.curvex1, m.curvey1 ) <|
                List.map
                    (\( ( a, b ), ( c, d ) ) -> Pull ( a, b ) ( c, d ))
                    m.pulls


stampString m stamp =
    case stamp of
        Filled ->
            "filled "

        Outlined ->
            "outlined "


maybeCurveHelper m x =
    if m.hasCurveHelper then
        group <| (x |> curveHelper) :: flashingCircles m

    else
        group <| x :: flashingCircles m


shapeFun m =
    (case m.draw of
        Filled ->
            maybeCurveHelper m (filled (colourFun m) (stencilFun m))

        Outlined ->
            maybeCurveHelper m (outlined (lineStyleFun m) (colourFun m) (stencilFun m))
    )
        |> (if m.hasMove then
                move ( m.x, m.y )

            else
                \x -> x
           )
        |> (if m.hasRotate then
                rotate (degrees m.angle)

            else
                \x -> x
           )
        |> (if m.hasScale then
                scale m.scl

            else
                \x -> x
           )
        |> (if m.hasScaleX then
                scaleX m.scl

            else
                \x -> x
           )
        |> (if m.hasScaleY then
                scaleY m.scl

            else
                \x -> x
           )
        |> (if m.hasMakeTransparent then
                makeTransparent m.alpha

            else
                \x -> x
           )


clrString m clr =
    case clr of
        RGB ->
            "(rgb " ++ String.fromFloat m.red ++ " " ++ String.fromFloat m.green ++ " " ++ String.fromFloat m.blue ++ ")"


colourFun m =
    case m.clr of
        RGB ->
            rgb m.red m.green m.blue


transformString m t =
    case t of
        Rotate ->
            "|> rotate (degrees " ++ String.fromFloat m.angle ++ ")"

        Scale ->
            "|> scale " ++ String.fromFloat m.scl

        ScaleX ->
            "|> scaleX " ++ String.fromFloat m.sclx

        ScaleY ->
            "|> scaleY " ++ String.fromFloat m.scly

        MakeTransparent ->
            "|> makeTransparent " ++ String.fromFloat m.alpha

        CurveHelper ->
            "|> curveHelper "


styleString m =
    "("
        ++ (case m.style of
                Solid ->
                    "solid "

                Dotted ->
                    "dotted "

                Dashed ->
                    "dashed "

                Longdash ->
                    "longdash "

                Dotdash ->
                    "dotdash "
           )
        ++ String.fromFloat m.lineWidth
        ++ ")"



--


lineStyleFun m =
    case m.style of
        Solid ->
            solid m.lineWidth

        Dotted ->
            dotted m.lineWidth

        Dashed ->
            dashed m.lineWidth

        Longdash ->
            longdash m.lineWidth

        Dotdash ->
            dotdash m.lineWidth


titleColour =
    rgb 100 175 120



-- format a string as code


code str =
    str |> text |> fixedwidth |> size 7 |> filled black



-- arrow keys


leftArrowKey rectcol tricol x y =
    group
        [ polygon [ ( 6, 0 ), ( 0, 10 ), ( -6, 0 ) ] |> outlined (solid 1) (rgba 0 0 0 0.2) |> rotate (degrees 90) |> move ( x, y )
        , polygon [ ( 6, 0 ), ( 0, 10 ), ( -6, 0 ) ] |> filled tricol |> rotate (degrees 90) |> move ( x, y )
        ]


rightArrowKey rectcol tricol x y =
    group
        [ polygon [ ( 6, 0 ), ( 0, 10 ), ( -6, 0 ) ] |> outlined (solid 1) (rgba 0 0 0 0.2) |> rotate (degrees -90) |> move ( x, y )
        , polygon [ ( 6, 0 ), ( 0, 10 ), ( -6, 0 ) ] |> filled tricol |> rotate (degrees -90) |> move ( x, y )
        ]


downArrowKey rectcol tricol x y =
    group
        [ polygon [ ( 40, 0 ), ( 0, 10 ), ( -40, 0 ) ] |> outlined (solid 1) (rgba 0 0 0 0.2) |> rotate (degrees 180) |> move ( x, y )
        , polygon [ ( 40, 0 ), ( 0, 10 ), ( -40, 0 ) ] |> filled tricol |> rotate (degrees 180) |> move ( x, y )
        ]


upArrowKey rectcol tricol x y =
    group
        [ polygon [ ( 40, 0 ), ( 0, 10 ), ( -40, 0 ) ] |> outlined (solid 1) (rgba 0 0 0 0.2) |> move ( x, y )
        , polygon [ ( 40, 0 ), ( 0, 10 ), ( -40, 0 ) ] |> filled tricol |> move ( x, y )
        ]
